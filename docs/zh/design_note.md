# Oath 所有权建模库：细节设计思路

本文件记录 Oath 库的设计思路与实现细节取舍。

## 为什么需要 Oath？

在现代 C++ 开发中，资源的生命周期控制主要依赖于：

- 智能指针（如 `unique_ptr`, `shared_ptr`）的语义约定；
- 裸指针/ RAII 混用导致的行为不确定性；
- 开发者的隐式约定与经验主导。

这些手段**在行为层可运行**，但在**语义层不可验证**。

C++ 虽然拥有精细的资源管理模型（RAII, move, copy, noexcept...），却**缺乏一种可读、可控、可解释的“所有权表达机制”**。

而 Rust 所构建的编译期所有权检查机制虽然优秀，但无法直接迁移到 C++ 的语言生态中。

于是我提出了 Oath：  
> 一个以最小成本为目标，构建现代 C++ 所有权表达语义系统的轻量库。

---

## 🎯 Oath 的目标不是模仿 Rust，而是为 C++ 构建一个：

- ✅ 显式可见的所有权传递链
- ✅ 可追踪的 borrow / return 语义结构
- ✅ 不依赖 GC / 不引入虚表的轻量运行时
- ✅ 可被文档化、教学、系统化迁移的工程机制
- ✅ 与现有 STL / 裸指针 / 项目代码共存的 **渐进集成路径**

---

## 🧠 设计哲学

### 1. 所有权不是语法，而是结构

C++ 缺少语言级生命周期建模机制，我通过类型系统封装 `Handle<T>`, `Owned<T>`, `Borrowed<T>` 等构建结构性表达语义。

### 2. 安全不是强制，而是选择

Oath 不强迫开发者遵循，而是提供一套**工程期望表达接口**，使用者可通过 `OATH_RUNTIME_CHECK` 切换检查机制。

### 3. 借用链可见、可归还

借用不止是 `const T&`，Oath 通过 `Borrowed<T>` 和 `return_handle()` 建立显式生命周期控制。

### 4. 与原生系统协同
所有核心封装零虚函数、无 RTTI，具备编译期优化空间，兼容裸指针与 STL allocator 结构。

---
## 🧩 核心类型设计说明（摘要）

| 类型 | 描述 | 特点 |
|------|------|------|
| `Handle<T>` | 裸资源包装，所有权流转的底层载体 | 可追踪借用链 |
| `Owned<T>` | 唯一拥有资源 | 可移动，不可复制，自动析构 |
| `Borrowed<T>` | 临时借用，归还后才允许再次使用原资源 | 借用链管理 |
| `Value<T>` | 值拷贝封装 | 不参与生命周期管理 |
| `Readonly<T>` | 可读视图，不允许变更 | 类似 `string_view` |
| `Result<T,E>` / `Option<T>` | 表达失败/状态结构 | 替代裸异常/null 模式 |

详细行为说明见 [behaviours.md](behaviours.md)。

---

## 🚧 为什么不是智能指针？

`shared_ptr` 语义模糊、不支持语义追踪，且易发生资源泄漏循环；
`unique_ptr` 无法表示借用或只读，不适合表达资源转移过程。

Oath 提供的是一种 **“语义可解释 + 生命周期清晰 + 逻辑路径可控”** 的资源表达形式，是对 STL 智能指针模型的语义层补足，而非替代内存模型。

---

## 🚀 后续方向

- ✅ 完成 C++14~20 三版本支持
- ✅ 增强 STL 兼容（与 vector/map/allocator 集成）
- ✅ 编写教学型样例，服务教育和框架开发者
- ✅ 建立更强的社区表达结构（文档、站点、传播材料）

---

## 📎 声明

本项目中的类型系统、命名约定与语义表达结构由 pjh456 于 2025 年 5 月独立构建与实现，旨在解决现代 C++ 项目中资源管理语义表达困难的问题。

尽管其概念可能与其他语言（如 Rust）中的所有权模型存在相似性，但该实现是基于 C++ 语言特性与工程实践需求所提出的结构性解法，而非语法层模仿。

欢迎学习、提出建议或进行贡献；  
但不建议在尚未正式发布前 fork / 重构 / 改名发布为替代项目，以免混淆核心思想。

---

## 🧭 如果你愿意使用 Oath，你应该知道：

- 它不是智能指针魔改；
- 它不是语言级 borrow checker；
- 它是 C++ 资源表达的一次**建模尝试**；
- 它希望成为一个“能写清楚语义的工具”，不再靠习惯、评论、假设维持资源安全。

---